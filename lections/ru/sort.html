<h2>Вступление</h2>

<p>Сортировка &ndash; одна из самых распространённых подзадач, часто встречающаяся
в задачах всех уровней сложности. Существует множество алгоритмов, решающих её
&ndash; алгоритмов сортировки. В стандартных библиотеках большинства современных
языков программирования уже содержится эффективный алгоритм сортировки, и
вам, вероятно, очень редко придётся реализовывать его самостоятельно.
Несмотря на это, в этой лекции приведены несколько алгоритмов сортировки
в целях иллюстрации.</p>

<h2>Постановка задачи</h2>

<p>Простым примером сортировки является расположение набора чисел по убыванию
или возрастанию. Точное определение сортировки более обобщено: сортировка
упорядочивает заданный набор объектов согласно определённому отношению между
ними. Например, объектами могут быть числа, строки, точки в пространстве, а
отношением &ndash; обычная операция сравнения.</p>

<h2>Сортировка вставками (Сложность: $O(N^2)$)</h2>

<p>Один из самых простых алгоритмов сортировки &ndash; сортировка вставками. Его идея
заключается в поддерживании в левой части массива отсортированного отрезка
и постепенном его расширении вправо за счёт перемещения очередного соседнего
элемента в соответствующую ему позицию.</p>

<p>В качестве иллюстрации вы можете посмотреть <a href="https://www.youtube.com/watch?v=ROalU379l3U">это видео.</a></p>

<p>Реализация:</p>

<!--@Listing:sort/insertion/ru/*:Function-->

<p>На практике алгоритмы сортировки со сложностью большей $O(N \log N)$ не
применяются, сортировка вставками приведена здесь только из-за своей простоты.</p>

<h2>Сортировка слиянием (Сложность: $O(N \log N)$)</h2>

<p>Теоретически доказано, что алгоритмы сортировки, основанные на сравнениях,
не могут работать быстрее чем за $O(N \log N)$. Хотя сортировка слиянием
чаще всего работает медленнее чем оптимальные алгоритмы (на константу), она интересна идеей,
проста в реализации и пригодна для использования в решении задач (хотя лучше
всё же использовать сортировку из стандартной библиотеки вашего языка).</p>

<p>Идея сортировки слиянием заключается в следующем: допустим мы знаем, что
массив можно разбить на две части, и каждая из них уже будет отсортирована.
Нам нужно лишь "слить" эти две части, и мы получим отсортированный массив.</p>

<p>Для слияния мы создаём новый массив, изначально пустой. Затем мы параллельно
идём по двум частям изначального массива и добавляем в новый массив меньший
элемент из двух текущих.</p>

<p>Осталось лишь понять, как нам отсортировать две части массива независимо.
На самом деле это довольно просто. Мы просто вызовем этот же алгоритм
для каждой части по отдельности. Сортировка слиянием &ndash; один из хороших
примеров <em>рекурсии</em>, которой посвящена отдельная лекция. Если вы
ещё не знакомы с рекурсией, можете вернуться к этому алгоритму позже, самая
важная часть этой лекции &ndash; алгоритмы сортировки в стандартных библиотеках
различных языков.</p>

<p>И снова <a href="https://www.youtube.com/watch?v=XaqR3G_NVoo">иллюстративное видео.</a></p>

<p>Реализация:</p>

<!--@Listing:sort/merge/ru/*:Function-->

<h2>Алгоритмы сортировки в стандартных библиотеках различных языков</h2>

<p>Практически во всех "олимпиадных" языках программирования стандартная
библиотека содержит эффективный алгоритм сортировки со сложностью $O(N \log N)$,
использование которого &ndash; лучший вариант при решении задач.</p>

<h3>C++</h4>

<p>Стандартный способ сортировки в C++ &ndash; использование алгоритма <code>std::sort</code>.
Он реализован в виде комбинации нескольких эффективных алгоритмов: quicksort и
heapsort, и определён следующим образом:</p>

<pre><code class="language-cpp">void std::sort(iterator begin, iterator end);
</code></pre>

<p>В C++ возможно автоматическое преобразование указателей в итераторы, поэтому
<code>std::sort</code> можно использовать для сортировки обычных массивов следующим образом:</p>

<pre><code class="language-cpp">int a[100];
//...
sort(a, a + 100);   //100 - длина массива.
</code></pre>

<p>Сортировка объектов <code>std::vector</code> и <code>std::deque</code>
чаще всего выглядит так:</p>

<pre><code class="language-cpp">vector&lt;int&gt; v(n);
//...
sort(v.begin(), v.end());
</code></pre>

<h3>Java</h3>

<p>В Java для сортировки используют метод <code>Arrays.sort</code>, одну из
версий quicksort, определённую как:</p>

<pre><code class="language-java">static void sort(int[] a);
static void sort(int[] a, int fromIndex, int toIndex);  //[fromIndex, toIndex)
//так же для всех остальных примитивных типов и Object
</code></pre>

<h3>Python</h3>

<p>В Python два основных способа сортировки &ndash; функция <code>sorted</code>,
которая возвращает отсортированную копию списка, не изменяя оригинал, и метод
<code>list.sort</code> для сортировки списка in-place, не создавая копии.
Оба подхода используют алгоритм timsort. Определения:</p>

<pre><code class="language-python">sorted(iterable) -> list
list.sort() -> None
</code></pre>

<h2>Сортировка сложных типов. Собственные компараторы</h2>

<p>Иногда в задаче требуется отсортировать не числа, а некоторые сложные структуры,
состоящие из нескольких элементов. Для сортировки таких объектов чаще всего нужно
вручную указывать параметр, который будет сравниваться при сортировке. Для
этого и предназначены компараторы. Компаратор &ndash; некоторая функция, которая
определяет, как должны сравниваться объекты определённого типа. В разных языках
программирования компараторы реализованы по-разному. Рассмотрим их по-отдельности.</p>

<h3>C++</h3>

<p>В C++ компаратор &ndash; логическая функция, принимающая два объекта, и
возвращающая <code>true</code> только тогда, когда первый объект <strong>
должен</strong> находится в отсортированном массиве перед вторым. Обратите
внимание, что если объекты "равны" (относительный порядок не имеет значения),
компаратор <strong>должен</strong> вернуть <code>false</code>. Иначе вы получите
абсолютно непонятные ошибки времени выполнения. Простыми словами, компаратор
в C++ соответствует операции "строго меньше", $a < b$.</p>

<p><code>std::sort</code> может принимать компаратор как опциональный третий
аргумент:</p>

<pre><code class="language-cpp">void std::sort(iterator begin, iterator end, comparator comp);
</code></pre>

<p>Иногда вам не нужно явно определять компаратор для сортировки сложных
структур: если для структуры определён оператор "меньше", то он будет
использоваться в качестве компаратора по умолчанию. Например, этот оператор
определён для типа <code>std::pair</code>: вы можете сортировать пары так же,
как и обычные числа, при этом сначала они будут сравниваться по первому элементу,
а если они равны &ndash; то по второму.</p>

<h3>Java</h3>

<p>В Java компаратор &ndash; функция, принимающая два объекта, и
возвращающая <code>int</code>, знак которого определяет отношение между ними.
Если компаратор возвращает отрицательное число, первый объект должен находиться
перед вторым (быть "меньше"), положительное - после второго ("больше"), ноль -
относительный порядок не имеет значения (объекты "равны").</p>

<p>Стоит отметить, что сортировка по компаратору поддерживается в Java только
для объектов (не примитивов). Чаще всего компараторы используются для сортировки
сложных структур, которые реализуются с помощью объектов, так что проблем это
ограничение обычно не вызывает.</p>

<p>Метод <code>Arrays.sort</code> для сортировки по компаратору определён так:</p>

<pre><code class="language-java">static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c);
static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c);
</code></pre>

<h3>Python</h3>

<p>В Python отсутствует такое понятие как "компаратор", вместо этого для
сортировки сложных структур используются собственные <strong>ключи</strong>.
Ключ - это функция, преобразующая объект в некоторое значение, которое будет
сравниваться с соответствующими значениями других объектов при сортировке.
То есть, в Python вы определяете не "как" сравниваются объекты, а только "по
какому параметру". Это немного ограничивает свободу действий, но часто этого
хватает.</p>

<p>Кроме этого, в Python при сортировке можно использовать опциональный параметр
<code>reverse</code> для сортировки в обратном порядке.

<p>Определения функций:</p>

<pre><code class="language-python">sorted(iterable, key=None, reverse=False) -> list
list.sort(key=None, reverse=False) -> None
</code></pre>

<h3>Пример</h3>

<p>Приведём пример использования компараторов в реальной жизни. Будем
сортировать результаты команд на олимпиаде по программированию по системе ACM
в порядке мест. То есть, место команды выше места другой команды, если она решила
больше задач, или у неё меньше штраф.<p>

<!--@Listing:acm-sort/ru/*-->

<h3>Транзитивность</h3>

<p>При написании собственных компараторов в C++ и Java следует помнить об одном важном правиле:
транзитивности. Компаратор является транзитивным, если из условий $a < b$ и
$b < c$ гарантированно следует, что $a < c$. Это может казаться очевидным, но для
необычных компараторов, иногда применяющихся в сложных задачах, это правило
может не выполняться. В таком случае результат сортировки не определён.
Всегда следите за транзитивностью компараторов!</p>

<h2>Понятие стабильной сортировки</h2>

<p>Иногда от сортировки нам требуется определённое условие: она не должна менять
местами "равные" элементы. Это может показаться бессмысленным, но стоит вспомнить
о компараторах для сложных типов. Достаточно просто посмотреть на пример из
предыдущего раздела. Структура <code>team</code> состояла из названия, количества решённых
задач и штрафа, но компаратор использовал только последние 2 поля, никак не
задействуя названия. Другими словами, две команды с одинаковыми штрафом и количеством
решённых задач "равны", несмотря на то, что поле <code>name</code> у них отличается.</p>

<p>Стабильная сортировка гарантирует, что при наличии таких объектов в
изначальном массиве, их относительное положение не изменится.</p>

<p>Пример: пусть у нас есть следующий набор команд:</p>

<pre><code>{"Team BSEU", 9, 200}
{"Team BSU", 10, 350}
{"Team BSUIR", 9, 200}
</code></pre>

<p>Существует два "корректных" варианта их сортировки:</p>

<pre><code>{"Team BSU", 10, 350}
{"Team BSEU", 9, 200}
{"Team BSUIR", 9, 200}
</code></pre>

<p>и</p>

<pre><code>{"Team BSU", 10, 350}
{"Team BSUIR", 9, 200}
{"Team BSEU", 9, 200}
</code></pre>

<p>Нестабильная сортировка (например, <code>std::sort</code> в C++) может отсортировать набор
обоими способами. Стабильная сортировка может получить только первый вариант,
так как относительное положение команд BSEU и BSUIR в нём сохраняется.</p>

<p>Разумеется, за стабильность приходится платить другими характеристиками.
Хотя оптимальные стабильные сортировки имеют сложность $O(N \log N)$, как и
нестабильные, они чаще всего работают немного медленнее (на константу).</p>

<h3>Стабильная сортировка в стандартных библиотеках языков</h3>

<p>В Java и Python стандартные алгоритмы сортировки (<code>Arrays.sort</code>,
<code>sorted</code> и <code>list.sort</code>) стабильны, и могут использоваться
во всех ситуациях.</p>

<p>В C++ предоставляется выбор между нестабильной сортировкой (<code>std::sort</code>)
и стабильной: <code>std::stable_sort</code>. Вторая определена так же, как и
первая:</p>

<pre><code class="language-cpp">void std::stable_sort(iterator begin, iterator end);
void std::stable_sort(iterator begin, iterator end, comparator comp);
</code></pre>
