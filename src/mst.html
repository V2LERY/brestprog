<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Минимальное остовное дерево. Алгоритм Прима. Алгоритм Крускала</title>

    <link rel="stylesheet" type="text/css" href="styles.css">

    <!-- MathJax for embedded LaTeX -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

    <!-- Google code prettify (and a hack for displaying all line numbers). -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
</head>

<body>

<h1>Минимальное остовное дерево. Алгоритм Прима. Алгоритм Крускала</h1>

<h3>Минимальное остовное дерево</h3>

<p>Остовным деревом графа называется дерево, которое можно получить из него
путём удаления некоторых рёбер. У графа может существовать несколько остовных
деревьев, и чаще всех их достаточно много.</p>

<img style="display: block; margin: auto" src="resources/grid_spanning_tree.png" />

<p>На иллюстрации приведено одно из остовных деревьев (рёбра выделены синим
цветом) решёткообразного графа.</p>

<p>Для взвешенных графов существует понятие <em>веса</em> остовного дерева,
которое определено как сумма весов всех рёбер, входящих в остовное дерево.
Из него натурально вытекает понятие <strong>минимального остовного
дерева</strong> &ndash; остовного дерева с минимальным возможным весом.</p>

<img style="display: block; margin: auto" src="resources/mst.png" />

<p>Для нахождения минимального остовного дерева графа существуют два основных
алгоритма: алгоритм Прима и алгоритм Крускала. Они оба имеют сложность
$O(M \log N)$, поэтому выбор одного из них зависит от ваших личных предпочтений.
В этой лекции мы разберём оба.</p>

<h3>Алгоритм Прима</h3>

<p>Алгоритм Прима в идее и реализации очень похож на алгоритм Дейкстры. Как и
в алгоритме Дейкстры, мы поддерживаем уже обработанную часть графа (минимального
остовного дерева), и постепенно её расширяем за счёт ближайших вершин.</p>

<p>Утверждается, что если разделить вершины графа на два множества (обработанные
и необработанные), первое из которых составляет связную часть минимального
остовного дерева, то ребро минимальной длины, связывающее эти два множества
гарантированно будет входить в минимальное остовное дерево.</p>

<p>Таким образом, для нахождения минимального остовного дерева начнём с
произвольной вершины и будем постепенно добавлять ближайшие к уже имеющимся.</p>

<img style="display: block; margin: auto" src="resources/Prim's_algorithm.png" />

<p>На иллюстрации красным цветом выделены рёбра, уже вошедшие в минимальный
остов, а чёрным &ndash; текущие кандидаты, из которых выбирается ребро с
минимальным весом.</p>

<h3>Реализация алгоритма Прима</h3>

<p>Будем искать вес минимального остовного дерева. Для нахождения ближайшей
вершины воспользуемся очередью с приоритетом (аналогично алгоритму Дейкстры),
в которой будем хранить пары (расстояние от остова до вершины, номер вершины).</p>

<pre class="prettyprint lang-c linenums">
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int INF = 1e9 + 7;

vector&lt;pair&lt;int, int&gt;&gt; graph;
bool used[100000];      //включили ли мы соответствующую вершину в остов

int main() {
    //Ввод графа...

    int mst_weight = 0;     //Текущий вес остова.

    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q;

    q.push({0, 0});     //Начнём с вершины 0.

    while (!q.empty()) {
        pair&lt;int, int&gt; c = q.top();
        q.pop();

        int dst = c.first, v = c.second;

        if (used[v]) {      //вершина уже добавлена в остов
            continue;
        }

        used[v] = true;
        mst_weight += dst;

        for (pair&lt;int, int&gt; e: graph[v]) {
            int u = e.first, len_vu = e.second;
            
            if (!used[u]) {
                q.push({len_vu, u});    //Заметьте: мы учитываем только длину ребра.
            }
        }
    }

    cout &lt;&lt; "Minimum spanning tree weight: " &lt;&lt; mst_weight &lt;&lt; endl;
}
</pre>

<h3>Алгоритм Крускала</h3>

<p>Алгоритм Крускала достаточно прост в своей идее и реализации. Он заключается
в сортировке всех рёбер в порядке возрастания длины, и поочерёдному добавлению
их в минимальный остов, если они соединяют различные компоненты связности.</p>

<p>Более формально: пусть мы уже нашли некоторые рёбра, входящие в минимальный остов.
Утверждается, что среди всех рёбер, соединяющих различные компоненты связности,
в минимальный остов будет входить ребро с минимальной длиной.</p>

<p>Для реализации алгоритма Крускала необходимо уметь сортировать рёбра по
возрастанию длины (для этого воспользуемся собственным типом данных) и проверять,
соединяет ли ребро две различных компоненты связности. Для этого будем
просто поддерживать текущие компоненты связности с помощью структуры данных DSU.</p>

<p>Визуализация работы алгоритма Крускала:</p>

<img style="display: block; margin: auto" src="resources/MST_kruskal.gif" />

<h3>Реализация алгоритма Крускала</h3>

<p>Используем реализацию DSU со всеми оптимизациями из соответствующей лекции:</p>

<pre class="prettyprint lang-c linenums">
int p[100000];
int rank[100000];

void init_dsu() {
    for (int i = 0; i &lt; 100000; i++) {
        p[i] = -1;
        rank[i] = 1;
    }
}

int get_root(int v) {
    if (p[v] == -1) {
        return v;
    } else {
        return p[v] = get_root(p[v]);   //На выходе из рекурсии переподвешиваем v
    }
}

bool merge(int a, int b) {
    int ra = get_root(a), rb = get_root(b);

    if (ra == rb) {
        return false;
    } else {
        if (rank[ra] &lt; rank[rb]) {
            p[ra] = rb;
        } else if (rank[rb] &lt; rank[ra]) {
            p[rb] = ra;
        } else {
            p[ra] = rb;
            rank[rb]++;
        }

        return true;
    }
}

//Тип для представления рёбер.
struct edge {
    int a, b, len;

    bool operator&lt;(const edge&amp; other) {
        return len &lt; other.len;
    }
}

int main() {
    vector&lt;edge&gt; edges;
    //Ввод edges...

    sort(edges.begin(), edges.end());

    int mst_weight = 0;

    for (edge e: edges) {
        if (merge(e.a, e.b)) {      //Если a и b находятся в разных компонентах,
            mst_weight += e.len;    //Добавить ребро в минимальный остов.
        }
    }

    cout &lt;&lt; "Minimum spanning tree weight: " &lt;&lt; mst_weight &lt;&lt; endl;
}
</pre>

<h3>Различия в скорости работы</h3>

<p>Хотя оба алгоритма работают за $O(M \log N)$, существуют константные различия
в скорости их работы. На разреженных графах (количество рёбер примерно равно
количеству вершин) быстрее работает алгоритм Крускала, а на насыщенных (количество
рёбер примерно равно квадрату количеству вершин) &ndash; алгоритм Прима (при
использовании матрицы смежности).</p>

<p>На практике чаще используется алгоритм Крускала.</p>