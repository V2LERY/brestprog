<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Система непересекающихся множеств (DSU)</title>

    <link rel="stylesheet" type="text/css" href="styles.css">

    <!-- MathJax for embedded LaTeX -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

    <!-- Google code prettify (and a hack for displaying all line numbers). -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
</head>

<body>

<h1>Система непересекающихся множеств (DSU)</h1>

<h3>Определение</h3>

<p>Система непересекающихся множеств &ndash; структура данных для эффективной
работы с <em>непересекающимися</em> множествами (каждый элемент принадлежит
только к одному множеству), позволяющий проверять, принадлежат ли два элемента
к одинаковому множеству, и объединять множества.</p>

<p>СНМ часто называют DSU, от <em>англ.</em> Disjoint Set Union, хотя DSU &ndash;
это название только операции объединения (Union). Впрочем, эта аббревиатура
уже устоялась в олимпиадном программировании, поэтому она будет использоваться
далее.</p>

<p>DSU представляет собой набор корневых деревьев (<strong>лес</strong>). Каждое
дерево соответствует определённому множеству. При реализации DSU необходимо
лишь подниматься вверх по деревьям, поэтому достаточно хранить для каждой
вершины только номер её прямого предка. Для этого используется массив $p$.</p>

<p>Для описания множества используется номер вершины, являющейся корнем
соответствующего дерева. Поэтому для определения, принадлежат ли два элемента
к одному и тому же множеству, для каждого элемента нужно найти корень
соответствующего дерева (поднимаясь вверх пока это возможно) и сравнить эти
корни.</p>

<p>Объединяются множества элементарно. Пусть нам нужно объединить множества
с корнями $a$ и $b$. Просто присвоим $p[a] = b$, тем самым подвесив всё дерево
$a$ к корню дерева $b$.</p>

<h3>Реализация: наивный вариант</h3>

<pre class="prettyprint linenums">
int p[100000];

void init_dsu() {
    for (int i = 0; i &lt; 100000; i++) {
        p[i] = -1;  //каждая вершина изначально является корнем отдельного дерева
    }
}

int get_root(int v) {
    if (p[v] == -1) {
        return v;
    } else {
        return get_root(p[v]);
    }
}

//a и b - любые вершины в деревьях
//возвращаемое значение обозначает, находились ли до вызова функции a и b в разных деревьях
bool merge(int a, int b) {
    int ra = get_root(a), rb = get_root(b);

    if (ra == rb) {
        return false;
    } else {
        p[ra] = rb;
        return true;
    }
}
</pre>

<p>При такой реализации создаётся 100000 вершин, каждая из которых является
отдельным деревом.</p>

<h3>Оптимизация 1: ранги вершин</h3>

<p>Можно заметить, что при такой реализации при постепенном объединении
деревьев глубина будет расти вплоть до $N$, так как деревья вырождаются
в связные списки. Разумеется, такая глубина не позволяет эффективно
использовать структуру данных. Поэтому нужно применять дополнительные
оптимизации, в первую очередь, при объединении деревьев.</p>

<p>Одна из самых простых и эффективных оптимизаций &ndash; поддерживать для
всех деревьев текущую глубину, и при объединении подвешивать дерево
с меньшей глубиной к корню дерева с большей глубиной. Глубина дерева
данной вершины поддерживается в виде её <strong>ранга</strong>. Строго
говоря, при применении дополнительной оптимизации (описанной ниже), ранг
вершины описывают не точную глубину дерева, а её верхнюю границу, но
это не играет роли.</p>

<h3>Реализация: ранги вершин</h3>

<pre class="prettyprint linenums">
int p[100000];
int rank[100000];

void init_dsu() {
    for (int i = 0; i &lt; 100000; i++) {
        p[i] = -1;
        rank[i] = 1;    //Начальное значение не играет роли.
    }
}

int get_root(int v) {
    if (p[v] == -1) {
        return v;
    } else {
        return get_root(p[v]);
    }
}

bool merge(int a, int b) {
    int ra = get_root(a), rb = get_root(b);

    if (ra == rb) {
        return false;
    } else {
        if (rank[ra] &lt; rank[rb]) {
            p[ra] = rb;
        } else if (rank[rb] &lt; rank[ra]) {
            p[rb] = ra;
        } else {            //Если оба дерева имеют одинаковую глубину,
            p[ra] = rb;     //неважно, какое из них подвешивать.
            rank[rb]++;     //При этом глубина нового дерева увеличится на 1.
        }

        return true;
    }
}
</pre>

<h3>Оптимизация 2: сжатие путей</h3>

<p>С помощью рангов максимальная глубина дерева (а значит и сложность операций)
понизилась до $\log N$. Этого уже может быть достаточно, но существует ещё одна
невероятно простая оптимизация (для её применения достаточно добавить в
предущий код пять символов). Эта оптимизация заключается в сжатии путей
при поиске корня.</p>

<p>Идея заключается в следующем: при поиске корня заданной вершины будем
переподвешивать её за найденный корень. Допустим, мы вызвали функцию
<code>get_root</code> для вершины, которую отделяют от корня дерева пять
других вершин. Рекурсивный вызов <code>get_root</code> обойдёт каждую
из них, и найдёт корень. На выходе из каждого рекурсивного вызова просто
переподвесим текущую вершину за только что найденный корень. Таким образом,
все пять вершин теперь будут подвешены напрямую к корню.</p>

<h3>Реализация: сжатие путей</h3>

<pre class="prettyprint linenums">
int p[100000];
int rank[100000];

void init_dsu() {
    for (int i = 0; i &lt; 100000; i++) {
        p[i] = -1;
        rank[i] = 1;    //Начальное значение не играет роли.
    }
}

int get_root(int v) {
    if (p[v] == -1) {
        return v;
    } else {
        return p[v] = get_root(p[v]);   //На выходе из рекурсии переподвешиваем v
    }
}

bool merge(int a, int b) {
    int ra = get_root(a), rb = get_root(b);

    if (ra == rb) {
        return false;
    } else {
        if (rank[ra] &lt; rank[rb]) {
            p[ra] = rb;
        } else if (rank[rb] &lt; rank[ra]) {
            p[rb] = ra;
        } else {            //Если оба дерева имеют одинаковую глубину,
            p[ra] = rb;     //неважно, какое из них подвешивать.
            rank[rb]++;     //При этом глубина нового дерева увеличится на 1.
        }

        return true;
    }
}
</pre>

<p>При такой реализации <em>амортизированная</em> сложность каждой операции
равна $O(\alpha(n))$, где $\alpha(n)$ &ndash; обратная функция Аккермана,
значение которой не превышает $5$ для всех разумных $n$. Другими словами,
амортизированная сложность каждой операции примерно равна $O(1)$.</p>

<p>Под амортизированной сложностью подразумевают отношение времени работы
алгоритма ко входным данным в <em>большинстве</em> случаев (не учитываются,
в частности, сжатия путей, которые происходят достаточно редко).</p>

<h3>Применение DSU</h3>

<p>Чаще всего DSU используется вместе с алгоритмом Крускала для нахождения
минимального остовного дерева графа.</p>

</body>
</html>