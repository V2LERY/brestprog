<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>НОД. НОК. Алгоритм Евклида</title>

    <link rel="stylesheet" type="text/css" href="styles.css">

    <!-- MathJax for embedded LaTeX -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

    <!-- Google code prettify (and a hack for displaying all line numbers). -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
</head>

<body>

<h1>НОД. НОК. Алгоритм Евклида</h1>

<h3>Наибольший общий делитель</h3>

<p>Как несложно догадаться, наибольший общий делитель (<em>англ.</em> greatest
common divisor) двух целых чисел &ndash; наибольшее число, на которое делится
каждое из них. Например:</p>

<p style="text-align: center">
$\gcd(15, 20) = 5$ <br />
$\gcd(12, 30) = 6$
</p>

<p>Сразу заметим важное свойство:</p>

$$\gcd(a, b) = \gcd(b, a)$$

<p>НОД играет большую роль как в математике, так и в программировании, и часто
встречается в задачах на различные темы.</p>

<h3>Алгоритм Евклида</h3>

<p>Алгоритм Евклида &ndash; один из первых алгоритмов в истории, использовался
ещё в Древней Греции, и дошёл до наших дней. В изначальном виде он назывался
"взаимным вычитанием", так как заключался в поочерёдном вычитании меньшего
числа из большего, пока одно из них не станет равным 0. Сегодня чаще всего
вместо вычитания используется взятие остатка от деления, но суть алгоритма
сохранилась.</p>

<p>Алгоритм заключается в построении ряда чисел следующего вида ($a &gt; b$):</p>

$$a, b, r_1, r_2, \ldots, r_n$$

<p>Где каждое последующее число является остатком от деления предпредыдущего
на предыдущее:</p>

<table style="margin: auto"><td>
$r_1 = a \bmod b$    <br />
$r_2 = b \bmod r_1$  <br />
$\ldots$ <br />
$r_n = r_{n - 2} \bmod r_{n - 1}$
</td></table>

<p>Ряд заканчивается, когда остаток от деления предпоследнего числа на
последнее становится равным 0:</p>

$$r_{n - 1} \bmod r_n = 0$$

<p>В таком случае утверждается, что:</p>

$$\gcd(a, b) = r_n$$

<p>Для доказательства этого утверждения сначала докажем следующее:
наборы общих делителей пары $(a, b)$ и пары $(b, r_1)$ полностью совпадают.
Рассмотрим произвольный (не обязательно наибольший) общий делитель $a$ и $b$:</p>

<table style="margin: auto; border: 1px solid black"><td style="padding: 5px">
<p>$t$ - общий делитель $a$ и $b$.</p>
<p>$r_1 = a \bmod b$, или $a = bq + r_1$.</p>
<p>Докажем, что $t$ также является общим делителем $b$ и $r_1$.</p>
<p>$b$ делится на $t$ по определению.</p>
<p>$r_1 = a - bq = t * ({a \over t} - {b \over t} * q)$, где ${a \over t}$ и ${b \over t}$ целые по определению.</p>
<p>Значит, $r_1$ также делится на $t$, что и требовалось доказать.</p>
</td></table>

<p>Из того, что все общие делители пар $(a, b)$ и $(b, r_1)$ совпадают
в частности следует, что $\gcd(a, b) = \gcd(b, r_1)$.</p>

<p>Далее по индукции можно доказать следующее:</p>

$$\gcd(a, b) = \gcd(b, r_1) = \gcd(r_1, r_2) = \ldots = \gcd(r_{n - 1}, r_n) = \gcd(r_n, 0)$$

<p>(Нуль в последнем выражении появился из условия $r_{n - 1} \bmod r_n = 0$).</p>

<p>Нуль делится на все числа, отличные от нуля, поэтому справедливо следующее
свойство:</p>

$$\gcd(x, 0) = x,\ для\ любого\ x \in \mathbb{N}.$$

<p>Следовательно,</p>

$$\gcd(a, b) = r_n,$$

<p>что и требовалось доказать.</p>

<h3>Варианты реализации алгоритма Евклида на C++</h3>

<p>Существует несколько вариантов реализации алгоритма Евклида, как итеративных
так и рекурсивных. Классическая итеративная реализация (работающая быстрее всех
рекурсивных) выглядит так:</p>

<pre class="prettyprint linenums">
int gcd(int a, int b) {
    if (a &lt; b) {
        swap(a, b);
    }

    while (b) {
        a %= b;
        swap(a, b);
    }

    return a;
}
</pre>

<p>Рекурсивно это же можно реализовать так:</p>

<pre class="prettyprint linenums">
int gcd(int a, int b) {
    if (a &lt; b) {
        swap(a, b);
    }

    if (b) {
        return gcd(b, a % b);
    } else {
        return a;
    }
}
</pre>

<p>Преимущество рекурсивной реализации заключается в возможности записать её в
очень кратком виде (предполагающим, что $a > b$):

<pre class="prettyprint linenums">
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
</pre>

<p>На практике разница во времени работы итеративного и рекурсивного вариантов
не столь значительна, так что вы можете использовать любой из них.</p>

<h3>Время работы алгоритма Евклида</h3>

<p>Согласно некоторым исследованиям, время работы алгоритма Евклида тесно
связано с числами Фибоначчи. Это выражается, в частности, в том, что два
последовательных числа Фибоначчи &ndash; наихудшие входные данные для алгоритма
Евклида. При $a = F_n$ и $b = F_{n - 1}$, алгоритм Евклида совершит ровно
$n - 2$ итерации. Отсюда можно выразить асимптотическую сложность алгоритма:
последовательность Фибоначчи возрастает с экспоненциальной скоростью, поэтому
алгоритм Евклида работает за $O(\log \min(a, b))$.</p>

<h3>Наименьшее общее кратное</h3>

<p>С понятием НОД связано также понятия наименьшего общего кратного (<em>англ.
</em> least common multiple). Наименьшее общее кратное двух натуральных чисел &ndash;
наименьшее натуральное число, которое делится на каждое из них. Оно обозначается
следующим образом:</p>

$$lcm(a, b)$$

<p>и связано с НОД формулой:</p>

$$lcm(a, b) = {a * b \over \gcd(a, b)}$$

<p>Реализация на C++:</p>

<pre class="prettyprint linenums">
int gcd(int a, int b) {
    return a / gcd(a, b) * b;   //используя форму a * b / gcd(a, b),
                                //можно получить переполнение на этапе a * b,
                                //поэтому следует выполнять деление до умножения
}
</pre>

<h3>НОД и НОК для произвольного количества чисел</h3>

<p>Обе функции легко обобщаются для произвольного числа аргументов
последовательным применением:</p>

$$\gcd(a, b, c, d) = \gcd(\gcd(\gcd(a, b), c), d)$$
$$lcm(a, b, c, d) = lcm(lcm(lcm(a, b), c), d)$$