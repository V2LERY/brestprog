<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Бор</title>

    <link rel="stylesheet" type="text/css" href="styles.css">

    <!-- MathJax for embedded LaTeX -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

    <!-- Google code prettify (and a hack for displaying all line numbers). -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
</head>

<body>

<h1>Бор</h1>

<h3>Опредение</h3>

<p>Бор, или префиксное дерево, &ndash; структура данных для эффективного хранения
и обработки строк. Вершины в боре соответствуют отдельным символам. В каждой
вершине хранится также числовое значение, обозначающее, сколько строк заканчиваются
в этой вершине. Строки представляются в виде путей по бору от корня (пустой строки)
до последнего символа.</p>

<img style="display: block; margin: auto" src="resources/trie.png" />

<p>В боре, изображённом выше, хранятся следующие строки:</p>

<ul>
    <li>"to" &ndash; 7 экземпляров</li>
    <li>"tea" &ndash; 3 экземпляра</li>
    <li>"ted" &ndash; 4 экземпляра</li>
    <li>"ten" &ndash; 12 экземпляров</li>
    <li>"A" &ndash; 15 экземпляров</li>
    <li>"i" &ndash; 11 экземпляров</li>
    <li>"in" &ndash; 5 экземпляров</li>
    <li>"inn" &ndash; 9 экземпляров</li>
</ul>

<p>Таким образом, в каждой вершине бора хранится количество строк, заканчивающихся
в этой вершине, и указатели на дочерние вершины, каждая из которых соответствует
определённому символу.</p>

<h3>Реализация</h3>

<p>При реализации бора используются указатели и динамическое выделение памяти.
Предполагается владение этими концепциями языка C++.</p>

<p>Во всех предыдущих реализациях структур данных деревья представлялись или
в виде массива с формулами перехода, или в виде списка смежности. Для реализации
бора необходимо "реальное" представление деревьев, каждая вершина в которых &ndash;
отдельный элемент, которому соответствует собственный тип данных. В каждой вершине
хранится массив указателей на дочерние вершины.</p>

<p>Реализуем тип данных для представления вершин в дереве:</p>

<pre class="prettyprint lang-c">
struct node {
    node *next[26];     //Массив указателей на следующие вершины
                        //next[i] - указатель на следующую вершину, соответствующую символу ('a' + i)
                        //(предполагается, что используются только строчные латинские буквы)

    int strings;        //Количество строк, заканчивающихся в этой вершине.

    node() {
        for (int i = 0; i &lt; 26; i++) {   //изначально заполняем next нулевыми указателями,
            next[i] = nullptr;           //так как следующие вершины ещё не созданы
        }

        strings = 0;
    }
};
</pre>

<p>Для добавления в бор очередной строки, нужно создать все необходимые вершины,
если они ещё не созданы, и увеличить счётчик строк в последней вершине на $1$:</p>

<pre class="prettyprint lang-c">
node *root;     //корневая вершина бора, соответствующая пустой строке.

void add(const string&amp; s) {
    node *cur_v = root;     //текущая вершина

    for (int i = 0; i &lt; s.length(); i++) {
        char c = s[i];

        if (cur_v->next[c - 'a'] == nullptr) {
            cur_v->next[c - 'a'] = new node();
        }

        cur_v = cur_v->next[c - 'a'];
    }

    cur_v->strings++;
}
</pre>

<p>Проверки наличия в боре строки реализуется похожим образом:</p>

<pre class="prettyprint lang-c">
bool has(const string&amp; s) {
    node *cur_v = root;

    for (int i = 0; i &lt; s.length(); i++) {
        cur_v = cur_v->next[s[i] - 'a'];
        if (cur_v == nullptr) {
            return false;
        }
    }

    return cur_v->strings > 0;
}
</pre>

<p>С бором можно выполнять множество операций, но большинство из них сводятся к обходу
всех строк с помощью DFS. Для примера давайте реализуем функцию, выводящую все строки,
содержащиеся в боре:</p>

<pre class="prettyprint lang-c">
string cur_str = "";

void write(node *v = root) {
    for (int i = 0; i &lt; v->strings; i++) {
        cout &lt;&lt; cur_str &lt;&lt; endl;
    }

    for (int i = 0; i &lt; 26; i++) {
        if (v->next['a' + i] != nullptr) {
            cur_str.push_back('a' + i);
            write(v->next['a' + i]);
            cur_str.pop_back();
        }
    }
}
</pre>

<h3>Применение</h3>

<p>Бор является достаточно легкомодифицируемой структурой данных, и в зависимости от
значений, хранимых в вершинах, и способа обхода с его помощью можно реализовать
множество различных операций. Конкретная реализация бора варьируется от задачи к
задаче.</p>

<p>Бор также используется как вспомогательная структура данных для более сложных
строковых алгоритмов, в частности, алгоритма Ахо-Корасик.</p>

</body>
</html>